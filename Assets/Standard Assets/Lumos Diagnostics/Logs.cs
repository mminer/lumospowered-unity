using System;
using System.Collections;
using System.Collections.Generic;
using System.Security.Cryptography;
using System.Text;
using UnityEngine;

/// <summary>
/// Remote error logging powerup for Lumos.
/// </summary>
public class LumosLogs
{
	static string _apiUrl = "http://logs.lumospowered.com/api/1";
	public static string apiUrl
	{
		private get { return _apiUrl; }
		set { _apiUrl = value; }
	}

	// TEMPORARY
	const string gameId = "8ba54a65";
	const string apiKey = "8ba54a65-7f51-4a33-a565-b9f5a0cf9028";

	// Settings
	public static bool recordLogs     { private get; set; }
	public static bool recordWarnings { private get; set; }
	public static bool recordErrors   { private get; set; }
	public static bool recordInEditor { private get; set; }

	/// <summary>
	/// The stored logs.
	/// </summary>
	//static List<LumosLog> logs = new List<LumosLog>();
	static Dictionary<string, LumosLog> logs = new Dictionary<string, LumosLog>();

	LumosLogs () { }

	/// <summary>
	/// Records a log message.
	/// </summary>
	/// <param name="message">The message.</param>
	/// <param name="stackTrace">Stack trace.</param>
	/// <param name="kind">Type of message (debug, warning, error, etc.).</param>
	public static void Record (string message, string trace, LogType type)
	{
		if (!ShouldBeRecorded(message, type)) { return; }

		LumosLog log;
		var key = type + message + trace;

		// If an identical message has been logged before, increment its total.
		if (logs.TryGetValue(key, out log)) {
			log.IncrementTotal();
		} else { // Otherwise create a new object.
			log = new LumosLog(key, type, message, trace);
			logs.Add(key, log);
		}
	}

	/// <summary>
	/// Sends the queued logs to the server.
	/// </summary>
	public static void Send ()
	{
		Lumos.RunRoutine(SendCoroutine());
	}

	/// <summary>
	/// Sends the queued logs to the server.
	/// </summary>
	static IEnumerator SendCoroutine ()
	{
		if (logs.Count == 0) { yield break; }

		// Respect option not to record logs while in the editor.
		if (Application.isEditor && !recordInEditor) {
			yield break;
		}

		// Skip out early if there's no internet connection.
		if (Application.internetReachability == NetworkReachability.NotReachable) {
			yield break;
		}

		var json = LumosJSON.JsonEncode(LogsToArrayList());
		var payload = Encoding.ASCII.GetBytes(json);

		// Create signature.
		var key = Encoding.UTF8.GetBytes(apiKey);
		var jsonBytes = Encoding.UTF8.GetBytes(json);
		var hash = new HMACSHA1(key).ComputeHash(jsonBytes);
		var signature = "LumosLogs " + Convert.ToBase64String(hash);

		// Add request headers.
		var headers = new Hashtable() {
			{ "Content-Type", "application.json" },
			{ "Authorization", signature }
		};

		// Send request.
		var url = apiUrl + "/games/" + gameId + "/logs";
		var www = new WWW(url, payload, headers);
		yield return www;
		Lumos.Log("Request: " + json);
		Lumos.Log("Response: " + www.text);

		// Parse the response.
		try {
			if (www.error != null) {
				throw new Exception(www.error);
			}

			var response = LumosJSON.JsonDecode(www.text) as Hashtable;

			// Display returned info if there is any.
			if (response.ContainsKey("message")) {
				Lumos.Log("Success: " + response["message"]);
				logs.Clear();
			}
		} catch (Exception e) {
			Lumos.LogError("Failure: " + e.Message);
			Lumos.LogWarning("Log messages not sent. Will try again at next timer interval.");
		}
	}

	/// <summary>
	/// Converts the queued logs to an array list suitable for encoding to JSON.
	/// </summary>
	/// <returns>An array list representation of the logs.</returns>
	static ArrayList LogsToArrayList ()
	{
		var list = new ArrayList();

		foreach (var entry in logs) {
			list.Add(entry.Value.ToHashtable());
		}

		return list;
	}

	/// <summary>
	/// Determines whether an incoming log fits the criteria of one that should be recorded.
	/// </summary>
	/// <param name="message">The message.</param>
	/// <param name="kind">Type of message (debug, warning, error, etc.).</param>
	/// <returns>Whether to record the log.</returns>
	static bool ShouldBeRecorded (string message, LogType type)
	{
		var record = true;

		// Skip messages generated by Lumos.
		if (message.StartsWith("[Lumos]")) {
			record = false;
		}

		// Only log message types that the user specifies.
		if ((type == LogType.Log       && !recordLogs) ||
			(type == LogType.Warning   && !recordWarnings) ||
			(type == LogType.Error     && !recordErrors) ||
			(type == LogType.Exception && !recordErrors) ||
			(type == LogType.Assert)) { // Ignore asserts
			record = false;
		}

		return record;
	}
}

using LumosPowered;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Security.Cryptography;
using System.Text;
using UnityEngine;

/// <summary>
/// Remote error logging add-on for Lumos.
/// </summary>
public class LumosLogs : MonoBehaviour
{
	#region Inspector Settings

	public bool recordLogs = false;
	public bool recordWarnings = true;
	public bool recordErrors = true;
	public string[] toIgnore = {};
	public bool recordInEditor = true;

	#endregion

	const string apiUrl = "http://ec2.matthewminer.com:8081/api/1/";

	// TEMPORARY
	const string gameId = "8ba54a65";
	const string apiKey = "8ba54a65-7f51-4a33-a565-b9f5a0cf9028";

	/// <summary>
	/// The stored logs.
	/// </summary>
	static List<Log> logs = new List<Log>();

	/// <summary>
	/// The log type labels.
	/// </summary>
	static readonly Dictionary<LogType, string> typeLabels = new Dictionary<LogType, string>() {
		{ LogType.Assert,    "assertion" },
		{ LogType.Error,     "error" },
		{ LogType.Exception, "exception" },
		{ LogType.Log,       "info" },
		{ LogType.Warning,   "warning" },
	};

	static LumosLogs instance;
	LumosLogs () { }

	void Awake ()
	{
		instance = this;
		// Set up debug log redirect.
		Application.RegisterLogCallback(Record);

		// Add send to Lumos timed events.
		Lumos.timedEvents += Send;
	}

	/// <summary>
	/// Records a log message.
	/// </summary>
	/// <param name="message">The message.</param>
	/// <param name="stackTrace">Stack trace.</param>
	/// <param name="kind">Type of message (debug, warning, error, etc.).</param>
	public static void Record (string message, string trace, LogType type)
	{
		// Skip messages generated by Lumos.
		if (message.StartsWith("[Lumos]")) {
			return;
		}

		// Only log message types that the user specifies.
		if ((type == LogType.Log       && !instance.recordLogs) ||
			(type == LogType.Warning   && !instance.recordWarnings) ||
			(type == LogType.Error     && !instance.recordErrors) ||
			(type == LogType.Exception && !instance.recordErrors) ||
			(type == LogType.Assert)) { // Ignore asserts
			return;
		}

		// Skip messages that the user explicitly says to ignore.
		foreach (var ignore in instance.toIgnore) {
			if (message.StartsWith(ignore)) {
				return;
			}
		}

		// If an identical message has been logged before, increment its total.
		for (int i = 0; i < logs.Count; i++) {
			if (logs[i].IsEqual(type, message, trace)) {
				logs[i].IncrementTotal();
				return;
			}
		}

		// Otherwise create a new message object.
		logs.Add(new Log(type, message, trace));
	}

	/// <summary>
	/// Sends the queued logs to the server.
	/// </summary>
	public static void Send ()
	{
		instance.StartCoroutine(SendCoroutine());
	}

	/// <summary>
	/// Sends the queued logs to the server.
	/// </summary>
	static IEnumerator SendCoroutine ()
	{
		if (logs.Count == 0) { yield break; }

		// Respect option not to record logs while in the editor.
		if (Application.isEditor && !instance.recordInEditor) {
			yield break;
		}

		// Skip out early if there's no internet connection.
		if (Application.internetReachability == NetworkReachability.NotReachable) {
			yield break;
		}
		
		var json = JSON.JsonEncode(LogsToArrayList());
		var payload = Encoding.ASCII.GetBytes(json);

		// Create signature.
		var key = Encoding.UTF8.GetBytes(apiKey);
		var jsonBytes = Encoding.UTF8.GetBytes(json);
		var hash = new HMACSHA1(key).ComputeHash(jsonBytes);
		var signature = "LumosLogs " + Convert.ToBase64String(hash);

		// Add request headers.
		var headers = new Hashtable() {
			{ "Content-Type", "application.json" },
			{ "Authorization", signature }
		};

		// Send request.
		var url = apiUrl + "games/" + gameId + "/logs";
		var www = new WWW(url, payload, headers);
		yield return www;
		Lumos.Log("Request: " + json);
		Lumos.Log("Response: " + www.text);

		// Parse the response.
		try {
			if (www.error != null) {
				throw new Exception(www.error);
			}

			var response = JSON.JsonDecode(www.text) as Hashtable;

			// Display returned info if there is any.
			if (response.ContainsKey("message")) {
				Lumos.Log("Success: " + response["message"]);
				logs.Clear();
			}
		} catch (Exception e) {
			Lumos.LogError("Failure: " + e.Message);
			Lumos.LogWarning("Log messages not sent. Will try again at next timer interval.");
		}
	}

	/// <summary>
	/// Converts the queued logs to an array list suitable for encoding to JSON.
	/// </summary>
	/// <returns>An array list representation of the logs.</returns>
	static ArrayList LogsToArrayList ()
	{
		var list = new ArrayList();

		foreach (var log in logs) {
			list.Add(log.ToHashtable());
		}

		return list;
	}

	/// <summary>
	/// A basic class for holding log information.
	/// </summary>
	class Log
	{
		public readonly string type; // info, error, etc.
		public readonly string message;
		public readonly string trace;
		public readonly string level;
		int total = 1;
		string hash;

		public Log (LogType type, string message, string trace)
		{
			this.type = typeLabels[type];
			this.message = message;
			this.trace = trace;
			this.level = Application.loadedLevelName;
			GenerateHash();
		}

		/// <summary>
		/// Converts the object to a hashtable suitable for adding to a JSON object.
		/// </summary>
		/// <returns>A hash table representation of this log.</returns>
		public Hashtable ToHashtable ()
		{
			var table = new Hashtable() {
				{ "type", type },
				{ "message", message },
				{ "trace", trace },
				{ "level", level },
				{ "total", total },
				{ "hash", hash }
			};
			return table;
		}

		/// <summary>
		/// Returns true if this log's properties are the same as another's.
		/// </summary>
		public bool IsEqual (LogType type, string message, string trace)
		{
			return this.type == typeLabels[type] && this.message == message && this.trace == trace;
		}

		/// <summary>
		/// Adds one to the total times the message has been logged.
		/// </summary>
		public void IncrementTotal ()
		{
			total++;
		}

		/// <summary>
		/// Creates an MD5 hash of the log from its properties.
		/// </summary>
		void GenerateHash ()
		{
			var combined = type + message + trace;
			var bytes = Encoding.ASCII.GetBytes(combined);
			var md5 = new MD5CryptoServiceProvider();
			var data = md5.ComputeHash(bytes);

			// Convert encrypted bytes back to a string (base 16).
			var hash = new StringBuilder();
			foreach (var b in data) {
				hash.Append(b.ToString("x2").ToLower());
			}

			this.hash = hash.ToString();
		}
	}
}
